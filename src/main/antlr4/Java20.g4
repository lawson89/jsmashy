grammar Java20;



compilationUnit: packageDeclaration? importDeclaration* typeDeclaration* EOF;
packageDeclaration: 'package' qualifiedName ';';
importDeclaration: 'import' 'static'? qualifiedName ('.' '*')? ';';
typeDeclaration: classDeclaration | interfaceDeclaration | ';';
classDeclaration: modifier* 'class' Identifier typeParameters? ('extends' typeType)? ('implements' typeList)? classBody;
interfaceDeclaration: modifier* 'interface' Identifier typeParameters? ('extends' typeList)? interfaceBody;
classBody: '{' classBodyDeclaration* '}';
interfaceBody: '{' interfaceBodyDeclaration* '}';
classBodyDeclaration: ';' | modifier* memberDeclaration | 'static'? block;
memberDeclaration: methodDeclaration | genericMethodDeclaration | fieldDeclaration | constructorDeclaration | genericConstructorDeclaration | interfaceDeclaration | classDeclaration;
methodDeclaration: typeTypeOrVoid Identifier formalParameters ('[' ']')? ('throws' qualifiedNameList)? (methodBody | ';');
genericMethodDeclaration: typeParameters methodDeclaration;
fieldDeclaration: typeType variableDeclarators ';';
constructorDeclaration: Identifier formalParameters ('throws' qualifiedNameList)? constructorBody;
genericConstructorDeclaration: typeParameters constructorDeclaration;
interfaceBodyDeclaration: modifier* interfaceMemberDeclaration | ';';
interfaceMemberDeclaration: constantDeclaration | interfaceMethodDeclaration | genericInterfaceMethodDeclaration | interfaceDeclaration | classDeclaration;
constantDeclaration: typeType variableDeclarators ';';
interfaceMethodDeclaration: modifier* typeTypeOrVoid Identifier formalParameters ('[' ']')? ('throws' qualifiedNameList)? (methodBody | ';');
genericInterfaceMethodDeclaration: typeParameters interfaceMethodDeclaration;
variableDeclarators: variableDeclarator (',' variableDeclarator)*;
variableDeclarator: variableDeclaratorId ('=' variableInitializer)?;
variableDeclaratorId: Identifier ('[' ']')*;
variableInitializer: arrayInitializer | expression;
arrayInitializer: '{' (variableInitializer (',' variableInitializer)* ','?)? '}';
typeTypeOrVoid: typeType | 'void';
typeType: (classOrInterfaceType | primitiveType) ('[' ']')*;
primitiveType: 'boolean' | 'char' | 'byte' | 'short' | 'int' | 'long' | 'float' | 'double';
classOrInterfaceType: Identifier typeArguments? ('.' Identifier typeArguments?)*;
typeArguments: '<' typeArgument (',' typeArgument)* '>';
typeArgument: typeType | '?' (('extends' | 'super') typeType)?;
qualifiedNameList: qualifiedName (',' qualifiedName)*;
formalParameters: '(' formalParameterList? ')';
formalParameterList: formalParameter (',' formalParameter)* (',' lastFormalParameter)? | lastFormalParameter;
formalParameter: modifier* typeType variableDeclaratorId;
lastFormalParameter: modifier* typeType '...' variableDeclaratorId;
methodBody: block;
constructorBody: block;
qualifiedName: Identifier ('.' Identifier)*;
typeParameters: '<' typeParameter (',' typeParameter)* '>';
typeParameter: Identifier ('extends' typeBound)?;
typeBound: typeType ('&' typeType)*;
typeList: typeType (',' typeType)*;
modifier: 'public' | 'protected' | 'private' | 'static' | 'abstract' | 'final' | 'native' | 'synchronized' | 'transient' | 'volatile' | 'strictfp';
block: '{' blockStatement* '}';
blockStatement: localVariableDeclaration ';' | statement | typeDeclaration;
localVariableDeclaration: modifier* typeType variableDeclarators;
statement: block | 'if' parExpression statement ('else' statement)? | 'for' '(' forControl ')' statement | 'while' parExpression statement | 'do' statement 'while' parExpression ';' | 'try' block (catchClause+ finallyBlock? | finallyBlock) | 'try' resourceSpecification block catchClause* finallyBlock? | 'switch' parExpression '{' switchBlockStatementGroup* switchLabel* '}' | 'synchronized' parExpression block | 'return' expression? ';' | 'throw' expression ';' | 'break' Identifier? ';' | 'continue' Identifier? ';' | ';' | expression ';' | Identifier ':' statement;
catchClause: 'catch' '(' modifier* catchType Identifier ')' block;
catchType: qualifiedName ('|' qualifiedName)*;
finallyBlock: 'finally' block;
resourceSpecification: '(' resources ';'? ')';
resources: resource (';' resource)*;
resource: modifier* typeType variableDeclaratorId '=' expression;
switchBlockStatementGroup: switchLabel+ blockStatement+;
switchLabel: 'case' (constantExpression | Identifier) ':' | 'default' ':';
forControl: enhancedForControl | forInit? ';' expression? ';' forUpdate?;
forInit: localVariableDeclaration | expressionList;
forUpdate: expressionList;
enhancedForControl: modifier* typeType variableDeclaratorId ':' expression;
parExpression: '(' expression ')';
expressionList: expression (',' expression)*;
constantExpression: expression;
expression: primary | expression '[' expression ']' | expression '(' expressionList? ')' | expression '.' Identifier | expression '.' 'this' | expression '.' 'new' nonWildcardTypeArguments? Identifier typeArguments? arguments? classBody? | expression '.' 'super' superSuffix | expression '.' 'explicitGenericInvocation' | expression '++' | expression '--' | ('+' | '-' | '++' | '--' | '~' | '!') expression | '(' typeType ')' expression | expression ('*' | '/' | '%') expression | expression ('+' | '-') expression | expression ('<<' | '>>' | '>>>') expression | expression ('<' | '>' | '<=' | '>=') expression | expression 'instanceof' typeType | expression ('==' | '!=') expression | expression '&' expression | expression '^' expression | expression '|' expression | expression '&&' expression | expression '||' expression | expression '?' expression ':' expression | expression ('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '>>=' | '>>>=' | '<<=' | '%=') expression | lambdaExpression;
lambdaExpression: lambdaParameters '->' lambdaBody;
lambdaParameters: Identifier | '(' (Identifier (',' Identifier)*)? ')' | '(' (formalParameter (',' formalParameter)*)? ')';
lambdaBody: expression | block;
primary: '(' expression ')' | 'this' | 'super' | literal | Identifier | typeType '.' 'class' | 'void' '.' 'class' | nonWildcardTypeArguments (explicitGenericInvocationSuffix | 'this' arguments);
literal: IntegerLiteral | FloatingPointLiteral | CharacterLiteral | StringLiteral | BooleanLiteral | 'null';
nonWildcardTypeArguments: '<' typeList '>';
arguments: '(' expressionList? ')';
explicitGenericInvocationSuffix: 'super' superSuffix | Identifier arguments;
superSuffix: arguments | '.' Identifier arguments?;

Identifier: [a-zA-Z_$] [a-zA-Z0-9_$]*;
IntegerLiteral: [0-9]+;
FloatingPointLiteral: [0-9]+ '.' [0-9]*;
CharacterLiteral: '\'' ( ~['\r\n\\] | '\\' . ) '\'';
StringLiteral: '"' ( ~["\r\n\\] | '\\' . )* '"';
BooleanLiteral: 'true' | 'false';
WS: [ \t\r\n]+ -> channel(HIDDEN);
COMMENT: '/*' .*? '*/' -> channel(HIDDEN);
LINE_COMMENT: '//' ~[\r\n]* -> channel(HIDDEN);